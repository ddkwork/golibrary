package stream_test

import (
	"github.com/ddkwork/golibrary/stream"
)

func generateIR(path string, callBack func(b *stream.Buffer)) {
	g := stream.NewGeneratedFile()
	g.P("package stream")
	g.P("")

	g.P("import (")
	g.P(" \"bufio\"")
	g.P(" \"bytes\"")
	g.P(" \"compress/gzip\"")
	g.P(" \"crypto/des\"")
	g.P(" \"encoding/binary\"")
	g.P(" \"encoding/hex\"")
	g.P(" \"encoding/json\"")
	g.P(" \"fmt\"")
	g.P(" \"io\"")
	g.P(" \"math/big\"")
	g.P(" \"math/rand\"")
	g.P(" \"os\"")
	g.P(" \"os/user\"")
	g.P(" \"path/filepath\"")
	g.P(" \"reflect\"")
	g.P(" \"regexp\"")
	g.P(" \"runtime\"")
	g.P(" \"slices\"")
	g.P(" \"strconv\"")
	g.P(" \"strings\"")
	g.P(" \"sync\"")
	g.P(" \"time\"")
	g.P(" \"unicode\"")
	g.P(" \"unicode/utf8\"")
	g.P("")

	g.P(" \"github.com/dc0d/caseconv\"")
	g.P(" \"github.com/rivo/uniseg\"")
	g.P(" \"mvdan.cc/gofumpt/format\"")
	g.P("")

	g.P(" \"github.com/ddkwork/golibrary/mylog\"")
	g.P(")")
	g.P("")

	g.P("type (")
	g.P(" Type interface {")
	g.P("  string | HexString | HexDumpString | ~[]byte | ~*bytes.Buffer | *big.Int | *Buffer")
	g.P(" }")
	g.P(" Buffer struct{ *bytes.Buffer }")
	g.P(")")
	g.P("")

	g.P("func NewBuffer[T Type](s T) *Buffer {")
	g.P(" switch s := any(s).(type) {")
	g.P(" case *Buffer:")
	g.P("  return s")
	g.P(" case []byte:")
	g.P("  return &Buffer{bytes.NewBuffer(s)}")
	g.P(" case *bytes.Buffer:")
	g.P("  return &Buffer{s}")
	g.P(" case string:")
	g.P("  if IsFilePath(s) {")
	g.P("   return &Buffer{Buffer: bytes.NewBuffer(mylog.Check2(os.ReadFile(s)))}")
	g.P("  }")
	g.P("  return &Buffer{Buffer: bytes.NewBufferString(s)}")
	g.P(" case HexString:")
	g.P("  return NewHexString(s)")
	g.P(" case HexDumpString:")
	g.P("  return NewHexDump(s)")
	g.P(" case *big.Int:")
	g.P("  return &Buffer{Buffer: bytes.NewBuffer(s.Bytes())}")
	g.P(" default:")
	g.P("  return &Buffer{Buffer: &bytes.Buffer{}}")
	g.P(" }")
	g.P("}")
	g.P("")

	g.P("func NewHexString(s HexString) *Buffer {")
	g.P(" decodeString := mylog.Check2(hex.DecodeString(string(s)))")
	g.P(" return NewBuffer(decodeString)")
	g.P("}")
	g.P("")

	g.P("type HexString string")
	g.P("")

	g.P("func (b *Buffer) HexString() HexString      { return HexString(hex.EncodeToString(b.Bytes())) }")
	g.P("func (b *Buffer) HexStringUpper() HexString { return HexString(fmt.Sprintf(\"%#X\", b.Bytes())[2:]) }")
	g.P("")

	g.P("type HexDumpString string")
	g.P("")

	g.P("func NewHexDump(hexdumpStr HexDumpString) (data *Buffer) {")
	g.P(" hexdump := string(hexdumpStr)")
	g.P(" defer func() {")
	g.P("  s := NewBuffer(\"\")")
	g.P("")

	g.P("  cut := `[]byte`")
	g.P("  cxx := fmt.Sprintf(\"%#v\", data.Bytes())")
	g.P("  cxx = cxx[len(cut):]")
	g.P("  s.WriteString(\"char data[] = \" + cxx + \";\\n\")")
	g.P("  mylog.Json(\"gen c++ code\", s.String())")
	g.P("  mylog.HexDump(\"recovery go buffer\", data.Bytes())")
	g.P(" }()")
	g.P(" hexdump = strings.TrimSuffix(hexdump, newLine)")
	g.P(" switch {")
	g.P(" case !hasAddress(hexdump) && !strings.Contains(hexdump, sep):")
	g.P("  hexdump = strings.ReplaceAll(hexdump, \" \", \"\")")
	g.P("  decodeString := mylog.Check2(hex.DecodeString(hexdump))")
	g.P("  data = NewBuffer(decodeString)")
	g.P(" case strings.Contains(hexdump, sep):")
	g.P("  split := strings.Split(hexdump, newLine)")
	g.P("  noAddress := make([]string, len(split))")
	g.P("  hexString := new(bytes.Buffer)")
	g.P("  for i, s := range split {")
	g.P("   if s == \"\" {")
	g.P("    continue")
	g.P("   }")
	g.P("   noAddress[i] = s[addressLen:strings.Index(s, sep)]")
	g.P("   noAddress[i] = strings.ReplaceAll(noAddress[i], \" \", \"\")")
	g.P("   hexString.WriteString(noAddress[i])")
	g.P("  }")
	g.P("  decodeString := mylog.Check2(hex.DecodeString(hexString.String()))")
	g.P("  data = NewBuffer(decodeString)")
	g.P(" default:")
	g.P("  split := strings.Split(hexdump, newLine)")
	g.P("  hexString := new(bytes.Buffer)")
	g.P("  for _, s := range split {")
	g.P("   if s == \"\" {")
	g.P("    continue")
	g.P("   }")
	g.P("   fields := strings.Split(s, \" \")")
	g.P("   for j, field := range fields {")
	g.P("    if j > 0 && field == \"\" {")
	g.P("     fields = fields[1:j]")
	g.P("     break")
	g.P("    }")
	g.P("   }")
	g.P("   for _, field := range fields {")
	g.P("    hexString.WriteString(field)")
	g.P("   }")
	g.P("  }")
	g.P("  decodeString := mylog.Check2(hex.DecodeString(hexString.String()))")
	g.P("  data = NewBuffer(decodeString)")
	g.P(" }")
	g.P(" return")
	g.P("}")
	g.P("")

	g.P("const (")
	g.P(" address    = \"00000000  \"")
	g.P(" sep        = \"|\"")
	g.P(" newLine    = \"\\n\"")
	g.P(" addressLen = len(address)")
	g.P(")")
	g.P("")

	g.P("func hasAddress(s string) bool {")
	g.P(" switch {")
	g.P(" case len(s) < len(\"00000000\"):")
	g.P("  return false")
	g.P(" case strings.Contains(s, address):")
	g.P("  return true")
	g.P(" }")
	g.P(" return s[len(\"00000000\")+1] == ' '")
	g.P("}")
	g.P("")

	g.P("func WriteGoFile[T Type](name string, data T) {")
	g.P(" s := NewBuffer(data)")
	g.P(" source, e := format.Source(s.Bytes(), format.Options{})")
	g.P(" mylog.CheckIgnore(e)")
	g.P(" if e != nil {")
	g.P("  write(name, false, s.Bytes())")
	g.P("  return")
	g.P(" }")
	g.P(" write(name, false, source)")
	g.P("}")
	g.P("")

	g.P("func WriteAppend[T Type](name string, data T)     { write(name, true, data) }")
	g.P("func WriteTruncate[T Type](name string, data T)   { write(name, false, data) }")
	g.P("func WriteBinaryFile[T Type](name string, data T) { write(name, false, data) }")
	g.P("")

	g.P("func write[T Type](name string, isAppend bool, data T) {")
	g.P(" mylog.Call(func() {")
	g.P("  if !CreatDirectory(filepath.Dir(name)) {")
	g.P("   mylog.Check(fmt.Errorf(\"create directory failed: %s\", filepath.Dir(name)))")
	g.P("  }")
	g.P("  fnCreateFile := func() (*os.File, error) {")
	g.P("   if isAppend {")
	g.P("    return os.OpenFile(name, os.O_RDWR|os.O_CREATE|os.O_APPEND, 0o666)")
	g.P("   }")
	g.P("   return os.Create(name)")
	g.P("  }")
	g.P("  f, e := fnCreateFile()")
	g.P("  mylog.CheckIgnore(e)")
	g.P("  if e != nil {")
	g.P("   switch {")
	g.P("   case os.IsExist(e):")
	g.P("    mylog.Check(f.Close())")
	g.P("    write(name, isAppend, data)")
	g.P("   case os.IsNotExist(e):")
	g.P("    mylog.Check(f.Close())")
	g.P("    write(name, isAppend, data)")
	g.P("   case os.IsPermission(e):")
	g.P("    return")
	g.P("   }")
	g.P("  }")
	g.P("  s := NewBuffer(data)")
	g.P("  mylog.Check2(f.Write(s.Bytes()))")
	g.P("  mylog.Check(f.Close())")
	g.P(" })")
	g.P("}")
	g.P("")

	g.P("func CreatDirectory(dir string) bool {")
	g.P(" dir = FixFilePath(dir)")
	g.P(" info, e := os.Stat(dir)")
	g.P(" mylog.CheckIgnore(e)")
	g.P(" if e == nil {")
	g.P("  if info.IsDir() {")
	g.P("   return true")
	g.P("  }")
	g.P("  mylog.Check(\"path exists but is not a directory \" + dir)")
	g.P(" }")
	g.P(" mylog.Warning(\"\", \"如果第一次看到这个错误，则说明当前目录下没有这个目录，请手动检查目录结构，如果第二次运行还出现权限错误则需要检查代码和系统问题\")")
	g.P(" switch {")
	g.P(" case os.IsExist(e):")
	g.P("  return info.IsDir()")
	g.P(" case os.IsNotExist(e):")
	g.P("  mylog.Check(os.MkdirAll(dir, os.ModePerm))")
	g.P("  return true")
	g.P(" default:")
	g.P("  mylog.Check(e)")
	g.P(" }")
	g.P(" return false")
	g.P("}")
	g.P("")

	g.P("func (b *Buffer) ReaderGzip() *Buffer {")
	g.P(" buf := ReaderGzip(b.Bytes()).Bytes()")
	g.P(" b.Reset()")
	g.P(" mylog.Check2(b.Write(buf))")
	g.P(" return b")
	g.P("}")
	g.P("")

	g.P("func ReaderGzip[T Type](data T) *Buffer {")
	g.P(" reader := mylog.Check2(gzip.NewReader(bytes.NewReader(NewBuffer(data).Bytes())))")
	g.P(" b := make([]byte, 1024*2)")
	g.P(" n := mylog.Check2(reader.Read(b))")
	g.P(" return NewBuffer(b[:n])")
	g.P("}")
	g.P("")

	g.P("func (b *Buffer) SplitBytes(size int) (blocks [][]byte) {")
	g.P(" blocks = make([][]byte, 0)")
	g.P(" quantity := b.Len() / size")
	g.P(" remainder := b.Len() % size")
	g.P(" for i := range quantity {")
	g.P("  blocks = append(blocks, b.Bytes()[i*size:(i+1)*size])")
	g.P("  if remainder != 0 {")
	g.P("   blocks = append(blocks, b.Bytes()[i*size:i*size+remainder])")
	g.P("  }")
	g.P(" }")
	g.P(" return")
	g.P("}")
	g.P("")

	g.P("func (b *Buffer) SplitString(size int) (blocks []string) {")
	g.P(" blocks = make([]string, 0)")
	g.P(" splitBytes := b.SplitBytes(size)")
	g.P(" for _, splitByte := range splitBytes {")
	g.P("  blocks = append(blocks, string(splitByte))")
	g.P(" }")
	g.P(" return")
	g.P("}")
	g.P("")

	g.P("func (b *Buffer) WritePackageName() {")
	g.P(" b.WriteStringLn(\"package \" + GetPackageName())")
	g.P("}")
	g.P("")

	g.P("func GetPackageName() (pkgName string) {")
	g.P(" return filepath.Base(mylog.Check2(filepath.Abs(\".\")))")
	g.P("}")
	g.P("")

	g.P("func (b *Buffer) CutString(left, right string) (cut string, found bool) {")
	g.P(" _, after, found := strings.Cut(b.String(), left)")
	g.P(" mylog.Check(found)")
	g.P(" before, _, f := strings.Cut(after, right)")
	g.P(" mylog.Check(f)")
	g.P(" before = strings.ReplaceAll(before, \"\\\\\", \"\")")
	g.P(" before = strings.ReplaceAll(before, \"/\", \"\")")
	g.P(" return before, true")
	g.P("}")
	g.P("func (b *Buffer) CutWithIndex(x, y int) []byte { return b.Bytes()[x:y] }")
	g.P("func (b *Buffer) NewLine() *Buffer             { b.WriteString(\"\\n\"); return b }")
	g.P("func (b *Buffer) QuoteWith(s string) *Buffer   { b.WriteString(s); return b }")
	g.P("func (b *Buffer) WriteBinary(order binary.ByteOrder, data any) {")
	g.P(" mylog.Check(binary.Write(b, order, data))")
	g.P("}")
	g.P("")

	g.P("func (b *Buffer) ReadBinary(order binary.ByteOrder) (data any) {")
	g.P(" mylog.Check(binary.Read(b, order, data))")
	g.P(" return b")
	g.P("}")
	g.P("")

	g.P("func (b *Buffer) WriteBytesLn(buf []byte) *Buffer {")
	g.P(" b.Write(buf)")
	g.P(" b.NewLine()")
	g.P(" return b")
	g.P("}")
	g.P("")

	g.P("func (b *Buffer) ReplaceAll(old, new string) *Buffer {")
	g.P(" s := strings.ReplaceAll(b.String(), old, new)")
	g.P(" b.Reset()")
	g.P(" b.WriteString(s)")
	g.P(" return b")
	g.P("}")
	g.P("")

	g.P("func (b *Buffer) TrimSuffix(suffix string) *Buffer {")
	g.P(" s := strings.TrimSuffix(b.String(), suffix)")
	g.P(" b.Reset()")
	g.P(" b.WriteString(s)")
	g.P(" return b")
	g.P("}")
	g.P("")

	g.P("func (b *Buffer) TrimPrefix(prefix string) *Buffer {")
	g.P(" s := strings.TrimPrefix(b.String(), prefix)")
	g.P(" b.Reset()")
	g.P(" b.WriteString(s)")
	g.P(" return b")
	g.P("}")
	g.P("")

	g.P("func (b *Buffer) TrimSpace() *Buffer {")
	g.P(" s := strings.TrimSpace(b.String())")
	g.P(" b.Reset()")
	g.P(" b.WriteString(s)")
	g.P(" return b")
	g.P("}")
	g.P("")

	g.P("func (b *Buffer) WriteStringLn(s string) *Buffer {")
	g.P(" b.WriteString(s)")
	g.P(" b.NewLine()")
	g.P(" return b")
	g.P("}")
	g.P("func (b *Buffer) Quote()          { b.WriteByte('\"') }")
	g.P("func (b *Buffer) ObjectBegin()    { b.WriteByte('{') }")
	g.P("func (b *Buffer) ObjectEnd()      { b.WriteByte('}') }")
	g.P("func (b *Buffer) SliceBegin()     { b.WriteByte('[') }")
	g.P("func (b *Buffer) SliceEnd()       { b.WriteByte(']') }")
	g.P("func (b *Buffer) Indent(deep int) { b.WriteString(strings.Repeat(\" \", deep)) }")
	g.P("")

	g.P("func (b *Buffer) CheckDesBlockSize() {")
	g.P(" mylog.Check(b.Len())")
	g.P(" mylog.Check(b.Len()%des.BlockSize == 0)")
	g.P("}")
	g.P("")

	g.P("func Concat[S ~[]E, E any](slices_ ...S) S { return slices.Concat(slices_...) }")
	g.P("func (b *Buffer) MergeByte(streams ...[]byte) []byte {")
	g.P(" return slices.Concat(b.Bytes(), slices.Concat(streams...))")
	g.P(" for _, s := range streams {")
	g.P("  b.Write(s)")
	g.P(" }")
	g.P(" return b.Bytes()")
	g.P("}")
	g.P("")

	g.P("func (b *Buffer) BigNumXorWithAlign(arg1, arg2 []byte, align int) (xorStream []byte) {")
	g.P(" xor := new(big.Int).Xor(new(big.Int).SetBytes(arg1), new(big.Int).SetBytes(arg2))")
	g.P(" alignBuf := make([]byte, align-len(xor.Bytes()))")
	g.P(" switch len(xor.Bytes()) {")
	g.P(" case 0:")
	g.P("  xorStream = alignBuf")
	g.P(" case align:")
	g.P("  xorStream = xor.Bytes()")
	g.P(" default:")
	g.P("  b.AppendByteSlice(xorStream, alignBuf, xor.Bytes())")
	g.P(" }")
	g.P(" return b.Bytes()")
	g.P("}")
	g.P("")

	g.P("func (b *Buffer) InsertStringWithSplit(size int, insert string) string {")
	g.P(" blocks := b.SplitString(size)")
	g.P(" b.Reset()")
	g.P(" for i, block := range blocks {")
	g.P("  b.WriteString(block)")
	g.P("  if i < len(blocks)-1 {")
	g.P("   b.WriteString(insert)")
	g.P("  }")
	g.P(" }")
	g.P(" return b.String()")
	g.P("}")
	g.P("")

	g.P("func (b *Buffer) InsertBytes(index int, insert []byte) []byte {")
	g.P(" start := b.Bytes()[:index]")
	g.P(" end := b.Bytes()[index:]")
	g.P(" b.Reset()")
	g.P(" b.Write(start)")
	g.P(" b.Write(insert)")
	g.P(" b.Write(end)")
	g.P(" return b.Bytes()")
	g.P("}")
	g.P("")

	g.P("func (b *Buffer) InsertByte(index int, ch byte) { b.InsertBytes(index, []byte{ch}) }")
	g.P("")

	g.P("func (b *Buffer) InsertRune(index int, r rune) {")
	g.P(" if uint32(r) < utf8.RuneSelf {")
	g.P("  b.InsertByte(index, byte(r))")
	g.P("  return")
	g.P(" }")
	g.P(" var buffer [4]byte")
	g.P(" n := utf8.EncodeRune(buffer[:], r)")
	g.P(" b.InsertBytes(index, buffer[:n])")
	g.P("}")
	g.P("")

	g.P("func (b *Buffer) InsertString(index int, s string) string {")
	g.P(" return string(b.InsertBytes(index, []byte(s)))")
	g.P("}")
	g.P("")

	g.P("func (b *Buffer) AppendByteSlice(bytesSlice ...[]byte) []byte {")
	g.P(" for _, slice := range bytesSlice {")
	g.P("  b.Write(slice)")
	g.P(" }")
	g.P(" return b.Bytes()")
	g.P("}")
	g.P("")

	g.P("func (b *Buffer) Contains(substr string) bool      { return strings.Contains(b.String(), substr) }")
	g.P("func ReadFileToLines(path string) (lines []string) { return NewBuffer(path).ToLines() }")
	g.P("")

	g.P("func Lines(x []byte) []string {")
	g.P(" l := strings.SplitAfter(string(x), \"\\n\")")
	g.P(" mylog.CheckNil(l)")
	g.P(" if l[len(l)-1] == \"\" {")
	g.P("  l = l[:len(l)-1]")
	g.P(" } else {")
	g.P("  l[len(l)-1] += \"\\n\\\\ No newline at end of file\\n\"")
	g.P(" }")
	g.P(" return l")
	g.P("}")
	g.P("")

	g.P("func (b *Buffer) ReplaceLine(index int, line string) *Buffer {")
	g.P(" lines := NewBuffer(b.String()).ToLines()")
	g.P(" lines[index] = line")
	g.P(" b.Reset()")
	g.P(" b.WriteString(b.LinesToString(lines)) // todo not working")
	g.P(" return b")
	g.P("}")
	g.P("")

	g.P("func (b *Buffer) LinesToString(lines []string) string {")
	g.P(" for _, line := range lines {")
	g.P("  b.WriteStringLn(line)")
	g.P(" }")
	g.P(" return b.String()")
	g.P("}")
	g.P("")

	g.P("func (b *Buffer) ToLines() (lines []string) {")
	g.P(" lines = make([]string, 0)")
	g.P(" newScanner := bufio.NewScanner(b.Buffer)")
	g.P(" for newScanner.Scan() {")
	g.P("  lines = append(lines, newScanner.Text())")
	g.P(" }")
	g.P(" return")
	g.P("}")
	g.P("")

	g.P("func SplitFileByLines(filePath string, size int) {")
	g.P(" lines := ReadFileToLines(filePath)")
	g.P(" if lines == nil {")
	g.P("  return")
	g.P(" }")
	g.P(" count := len(lines) / size")
	g.P(" div := len(lines) % size")
	g.P(" if div != 0 {")
	g.P("  count++")
	g.P(" }")
	g.P(" for i := range count {")
	g.P("  startIndex := i * size")
	g.P("  endIndex := (i + 1) * size")
	g.P("  if endIndex > len(lines) {")
	g.P("   endIndex = len(lines)")
	g.P("  }")
	g.P("  WriteTruncate(fmt.Sprint(i)+\".txt\", NewBuffer(\"\").LinesToString(lines[startIndex:endIndex]))")
	g.P(" }")
	g.P("}")
	g.P("")

	g.P("func ToLines[T string | []byte | *os.File | *bytes.Buffer](data T) (lines []string) {")
	g.P(" var r io.Reader")
	g.P(" switch data := any(data).(type) {")
	g.P(" case string:")
	g.P("  r = strings.NewReader(data)")
	g.P("  if IsFilePath(data) {")
	g.P("   b := mylog.Check2(os.ReadFile(data))")
	g.P("   r = bytes.NewReader(b)")
	g.P("  }")
	g.P(" case []byte:")
	g.P("  r = bytes.NewReader(data)")
	g.P(" case *os.File:")
	g.P("  r = data")
	g.P(" case *bytes.Buffer:")
	g.P("  r = data")
	g.P(" default:")
	g.P("  mylog.Check(fmt.Errorf(\"unsupported type %T\", data))")
	g.P(" }")
	g.P("")

	g.P(" lines = make([]string, 0)")
	g.P(" newReader := bufio.NewReader(r)")
	g.P("")

	g.P(" for {")
	g.P("  line, _, err := newReader.ReadLine()")
	g.P("  if mylog.CheckEof(err) {")
	g.P("   return lines")
	g.P("  }")
	g.P("  lines = append(lines, string(line))")
	g.P(" }")
	g.P("}")
	g.P("")

	g.P("func ReadLines(fullPath string) ([]string, error) {")
	g.P(" f := mylog.Check2(os.Open(fullPath))")
	g.P(" defer f.Close()")
	g.P("")

	g.P(" var lines []string")
	g.P(" scanner := bufio.NewScanner(f)")
	g.P(" for scanner.Scan() {")
	g.P("  lines = append(lines, scanner.Text())")
	g.P(" }")
	g.P(" return lines, scanner.Err()")
	g.P("}")
	g.P("")

	g.P("func WriteLines(lines []string, fullPath string) error {")
	g.P(" f := mylog.Check2(os.Create(fullPath))")
	g.P(" defer f.Close()")
	g.P("")

	g.P(" w := bufio.NewWriter(f)")
	g.P(" for _, line := range lines {")
	g.P("  mylog.Check2(fmt.Fprintln(w, line))")
	g.P(" }")
	g.P("")

	g.P(" return w.Flush()")
	g.P("}")
	g.P("")

	g.P("func IsZero(v reflect.Value) bool {")
	g.P(" if v.IsValid() {")
	g.P("  return true")
	g.P(" }")
	g.P(" return v.IsZero()")
	g.P("}")
	g.P("")

	g.P("func ReflectVisibleFields(object any) []reflect.StructField {")
	g.P(" fields := reflect.VisibleFields(reflect.TypeOf(object))")
	g.P(" var exportedFields []reflect.StructField")
	g.P(" for _, field := range fields {")
	g.P("  if field.Tag.Get(\"table\") == \"_\" || field.Tag.Get(\"json\") == \"_\" {")
	g.P("   continue")
	g.P("  }")
	g.P("  if !unicode.IsUpper(rune(field.Name[0])) {")
	g.P("   mylog.Trace(\"field name is not exported: \", field.Name)")
	g.P("   continue")
	g.P("  }")
	g.P("  exportedFields = append(exportedFields, field)")
	g.P(" }")
	g.P(" return exportedFields")
	g.P("}")
	g.P("")

	g.P("type Pool[T any] struct{ pool sync.Pool }")
	g.P("")

	g.P("func NewPool[T any](fn func() T) *Pool[T] {")
	g.P(" return &Pool[T]{")
	g.P("  pool: sync.Pool{")
	g.P("   New: func() any {")
	g.P("    return fn()")
	g.P("   },")
	g.P("  },")
	g.P(" }")
	g.P("}")
	g.P("")

	g.P("func (p *Pool[T]) Put(v T) { p.pool.Put(v) }")
	g.P("func (p *Pool[T]) Get() T  { return p.pool.Get().(T) }")
	g.P("")

	g.P("func SerialNumber(b string) string {")
	g.P(" to := bytes.Buffer{}")
	g.P(" for k, v := range b {")
	g.P("  if k%2 == 1 {")
	g.P("   to.WriteByte(byte(v))")
	g.P("   to.WriteByte(b[k-1])")
	g.P("  }")
	g.P(" }")
	g.P(" return to.String()")
	g.P("}")
	g.P("")

	g.P("func CutUint16(u uint16) uint8 {")
	g.P(" u >>= 4")
	g.P(" high4 := u & 0x0f << 4")
	g.P(" low4 := u & 0xf0 >> 4")
	g.P(" high4 |= low4")
	g.P(" return uint8(high4)")
	g.P("}")
	g.P("")

	g.P("func CutUint16_(u uint16) uint8 {")
	g.P(" ss := fmt.Sprintf(\"%x\", u)")
	g.P("")

	g.P(" out := string(ss[2]) + string(ss[1])")
	g.P(" decodeString := mylog.Check2(hex.DecodeString(out))")
	g.P(" if decodeString == nil {")
	g.P("  return 0")
	g.P(" }")
	g.P(" return decodeString[0]")
	g.P("}")
	g.P("")

	g.P("func SwapBytes2HexString2(src HexString) (dst string) {")
	g.P(" hexString := NewHexString(src)")
	g.P(" slices.Reverse(hexString.Bytes())")
	g.P(" return hex.EncodeToString(hexString.Bytes())")
	g.P("}")
	g.P("")

	g.P("func SwapBytes2HexString(src []byte) (dst HexString) {")
	g.P(" return NewBuffer(SwapBytes(src)).HexString()")
	g.P("}")
	g.P("")

	g.P("func SwapBytes(src []byte) (dst []byte) {")
	g.P(" slices.Reverse(src)")
	g.P(" return src")
	g.P(" return")
	g.P("")

	g.P(" to := bytes.Buffer{}")
	g.P(" for i := range src {")
	g.P("  to.WriteByte(src[len(src)-i-1])")
	g.P(" }")
	g.P(" return to.Bytes()")
	g.P("}")
	g.P("")

	g.P("func AlignString(s string, length int) (ss string) {")
	g.P(" width := uniseg.StringWidth(s)")
	g.P(" if width < length {")
	g.P("  repeat := strings.Repeat(\" \", length-width)")
	g.P("  ss = s + repeat")
	g.P("  return ss")
	g.P(" }")
	g.P(" return s")
	g.P("}")
	g.P("")

	g.P("func SubStrRunes(s string, length int) string {")
	g.P(" switch {")
	g.P(" case len(s) > length:")
	g.P("  rs := []rune(s)")
	g.P("  return string(rs[:length])")
	g.P(" case len(s) < length:")
	g.P("  repeat := strings.Repeat(\" \", length-len(s))")
	g.P("  return s + repeat")
	g.P("  return fmt.Sprintf(\"%-*s\", length, s)")
	g.P(" }")
	g.P(" return s")
	g.P("}")
	g.P("")

	g.P("func SlicesIndex(slice any, item any) int {")
	g.P(" s := reflect.ValueOf(slice)")
	g.P(" if s.Kind() != reflect.Slice {")
	g.P("  panic(\"findIndex: not slice\")")
	g.P(" }")
	g.P(" for i := range s.Len() {")
	g.P("  if reflect.DeepEqual(s.Index(i).Interface(), item) {")
	g.P("   return i")
	g.P("  }")
	g.P(" }")
	g.P(" return -1")
	g.P("}")
	g.P("")

	g.P("func SlicesInsert(slice any, index int, value any) any {")
	g.P(" s := reflect.ValueOf(slice)")
	g.P(" if s.Kind() != reflect.Slice {")
	g.P("  panic(\"Insert: not slice\")")
	g.P(" }")
	g.P("")

	g.P(" t := reflect.MakeSlice(s.Type(), s.Len()+1, s.Cap()+1)")
	g.P("")

	g.P(" reflect.Copy(t.Slice(0, index), s.Slice(0, index))")
	g.P("")

	g.P(" t.Index(index).Set(reflect.ValueOf(value))")
	g.P("")

	g.P(" reflect.Copy(t.Slice(index+1, s.Len()+1), s.Slice(index, s.Len()))")
	g.P(" return t.Interface()")
	g.P("}")
	g.P("")

	g.P("func MarshalJSON(v any) []byte {")
	g.P(" indent := mylog.Check2(json.MarshalIndent(v, \"\", \" \"))")
	g.P(" return indent")
	g.P("}")
	g.P("")

	g.P("func MarshalJsonToFile(v any, name string) {")
	g.P(" indent := mylog.Check2(json.MarshalIndent(v, \"\", \" \"))")
	g.P(" ext := filepath.Ext(name)")
	g.P(" if ext != \".json\" {")
	g.P("  name += \".json\"")
	g.P(" }")
	g.P(" WriteTruncate(name, indent)")
	g.P("}")
	g.P("")

	g.P("func JsonIndent(b []byte) string {")
	g.P(" buffer := new(bytes.Buffer)")
	g.P(" mylog.Check(json.Indent(buffer, b, \"\", \" \"))")
	g.P(" return buffer.String()")
	g.P("}")
	g.P("")

	g.P("func RandomAny[T any](slice []T) T {")
	g.P(" seed := rand.NewSource(time.Now().UnixNano())")
	g.P(" random := rand.New(seed)")
	g.P(" return slice[random.Intn(len(slice))]")
	g.P("}")
	g.P("")

	g.P("func GenA2Z() (letters []string) {")
	g.P(" return generateLatinAlphabets()")
	g.P("}")
	g.P("")

	g.P("func generateLatinAlphabets() []string {")
	g.P(" var alphabets []string")
	g.P(" for i := 'A'; i <= 'Z'; i++ {")
	g.P("  alphabets = append(alphabets, string(i))")
	g.P(" }")
	g.P(" return alphabets")
	g.P("}")
	g.P("")

	g.P("func GetWindowsLogicalDrives() []string {")
	g.P(" var driveLetters []string")
	g.P(" for _, s := range GenA2Z() {")
	g.P("  s += \":\\\\\"")
	g.P("  _, e := os.Stat(s)")
	g.P("  if e == nil {")
	g.P("   driveLetters = append(driveLetters, s)")
	g.P("  }")
	g.P(" }")
	g.P(" return driveLetters")
	g.P("}")
	g.P("")

	g.P("func ToCamel(data string, isCommit bool) string {")
	g.P(" s := fmt.Sprintf(\"%-50s\", caseconv.ToCamel(data))")
	g.P(" if isCommit {")
	g.P("  s += \"//\" + s")
	g.P(" }")
	g.P(" return s")
	g.P("}")
	g.P("")

	g.P("func ToCamelUpper(s string, isCommit bool) string {")
	g.P(" camel := ToCamel(s, isCommit)")
	g.P(" camel = strings.TrimSpace(camel)")
	g.P(" return strings.ToUpper(string(camel[0])) + camel[1:]")
	g.P("}")
	g.P("")

	g.P("func ToCamelToLower(s string, isCommit bool) string {")
	g.P(" camel := ToCamel(s, isCommit)")
	g.P(" camel = strings.TrimSpace(camel)")
	g.P(" return strings.ToLower(string(camel[0])) + camel[1:]")
	g.P("}")
	g.P("")

	g.P("func CurrentDirName(path string) (currentDirName string) {")
	g.P(" if path == \"\" {")
	g.P("  path = mylog.Check2(os.Getwd())")
	g.P(" }")
	g.P(" split := strings.Split(path, \"\\\\\")")
	g.P(" if split == nil {")
	g.P("  return BaseName(filepath.Dir(path))")
	g.P(" }")
	g.P(" return split[len(split)-1]")
	g.P("}")
	g.P("")

	g.P("func CopyDir(dst, src string) error {")
	g.P(" if !CreatDirectory(dst) {")
	g.P("  mylog.Check(\"CreatDirectory err\")")
	g.P(" }")
	g.P(" entries := mylog.Check2(os.ReadDir(src))")
	g.P(" for _, entry := range entries {")
	g.P("  if entry.IsDir() {")
	g.P("   mylog.Check(CopyDir(filepath.Join(dst, entry.Name()), filepath.Join(src, entry.Name())))")
	g.P("  } else {")
	g.P("   mylog.Check(copyFile(filepath.Join(dst, entry.Name()), filepath.Join(src, entry.Name())))")
	g.P("  }")
	g.P(" }")
	g.P(" return nil")
	g.P("}")
	g.P("")

	g.P("func copyFile(dst, src string) (err error) {")
	g.P(" s := mylog.Check2(os.Open(src))")
	g.P(" defer func() { mylog.Check(s.Close()) }()")
	g.P(" d := mylog.Check2(os.Create(dst))")
	g.P(" defer func() { mylog.Check(d.Close()) }()")
	g.P(" mylog.Check2(io.Copy(d, s))")
	g.P(" return nil")
	g.P("}")
	g.P("")

	g.P("func CopyFile(path, dstPath string) {")
	g.P(" WriteTruncate(dstPath, NewBuffer(path).Bytes())")
	g.P("}")
	g.P("")

	g.P("func MoveFile(src, dst string) {")
	g.P(" srcInfo := mylog.Check2(os.Stat(src))")
	g.P(" if !srcInfo.Mode().IsRegular() {")
	g.P("  mylog.Check(fmt.Sprintf(\"%s is not a regular file\", src))")
	g.P(" }")
	g.P(" dstInfo := mylog.Check2(os.Stat(dst))")
	g.P(" if !dstInfo.Mode().IsRegular() {")
	g.P("  mylog.Check(fmt.Sprintf(\"%s is not a regular file\", dst))")
	g.P(" }")
	g.P(" mylog.Check(os.SameFile(srcInfo, dstInfo))")
	g.P(" mylog.Check(os.Rename(src, dst))")
	g.P(" var in, out *os.File")
	g.P(" out = mylog.Check2(os.OpenFile(dst, os.O_RDWR|os.O_CREATE|os.O_TRUNC, srcInfo.Mode()))")
	g.P(" defer func() { mylog.Check(out.Close()) }()")
	g.P(" in = mylog.Check2(os.Open(src))")
	g.P(" mylog.Check2(io.Copy(out, in))")
	g.P(" mylog.Check(os.Remove(src))")
	g.P("}")
	g.P("")

	g.P("func IsFilePathEx(path string) (ok bool) {")
	g.P(" return isFilePath(path, true)")
	g.P("}")
	g.P("")

	g.P("func IsFilePath(path string) bool {")
	g.P(" return isFilePath(path, false)")
	g.P("}")
	g.P("")

	g.P("func isFilePath(path string, debug bool) bool {")
	g.P(" pattern := []string{\"://\", \"\\n\", \"*\", \"?\", \"<\", \">\", \"|\"}")
	g.P(" for _, s := range pattern {")
	g.P("  if strings.Contains(path, s) {")
	g.P("   return false")
	g.P("  }")
	g.P(" }")
	g.P(" stat, e := os.Stat(path)")
	g.P(" if e != nil {")
	g.P("  if debug {")
	g.P("   mylog.CheckIgnore(e)")
	g.P("  }")
	g.P("  return false")
	g.P(" }")
	g.P(" // strings.Contains(path, \"/\") || strings.Contains(path, \"\\\\\")")
	g.P(" mode := stat.Mode()")
	g.P(" return !mode.IsDir() && mode.IsRegular()")
	g.P("}")
	g.P("")

	g.P("func DirDepth(dirPath string) (depth int) {")
	g.P(" return strings.Count(dirPath, string(filepath.Separator))")
	g.P("}")
	g.P("")

	g.P("func IsDirRoot(path string) bool {")
	g.P(" return !strings.Contains(path, string(filepath.Separator))")
	g.P("}")
	g.P("")

	g.P("func IsDirEx(path string) (ok bool) {")
	g.P(" return isDir(path, true)")
	g.P("}")
	g.P("")

	g.P("func IsDir(path string) bool {")
	g.P(" return isDir(path, false)")
	g.P("}")
	g.P("")

	g.P("func isDir(path string, debug bool) bool {")
	g.P(" if strings.HasPrefix(path, \".\") && IsDirRoot(path) {")
	g.P("  return true")
	g.P(" }")
	g.P(" fi, e := os.Stat(path)")
	g.P(" if e != nil {")
	g.P("  return false")
	g.P(" }")
	g.P(" return fi != nil && fi.IsDir()")
	g.P("}")
	g.P("")

	g.P("func FixFilePath(path string) string {")
	g.P(" return strings.ReplaceAll(strings.ReplaceAll(path, \"\\\\\", \"/\"), \"//\", \"/\")")
	g.P("}")
	g.P("")

	g.P("func BaseName(path string) string {")
	g.P(" return TrimExtension(filepath.Base(mylog.Check2(filepath.Abs(path))))")
	g.P("}")
	g.P("func TrimExtension(path string) string { return path[:len(path)-len(filepath.Ext(path))] }")
	g.P("")

	g.P("func JoinHomeDir(path string) (join string)  { return joinHome(path, true) }")
	g.P("func JoinHomeFile(path string) (join string) { return joinHome(path, false) }")
	g.P("func joinHome(path string, isDir bool) (join string) {")
	g.P(" join = filepath.Join(HomeDir(), path)")
	g.P(" if !IsFilePath(join) {")
	g.P("  switch isDir {")
	g.P("  case true:")
	g.P("   mylog.Check(os.MkdirAll(join, os.ModePerm))")
	g.P("  default:")
	g.P("   f := mylog.Check2(os.Create(join))")
	g.P("   mylog.Check(f.Close())")
	g.P("  }")
	g.P(" }")
	g.P(" return")
	g.P("}")
	g.P("")

	g.P("func HomeDir() string {")
	g.P(" if u, e := user.Current(); e == nil {")
	g.P("  return u.HomeDir")
	g.P(" }")
	g.P(" if dir, e := os.UserHomeDir(); e == nil {")
	g.P("  return dir")
	g.P(" }")
	g.P(" return \".\"")
	g.P("}")
	g.P("")

	g.P("func RunDir() string {")
	g.P(" return filepath.Base(mylog.Check2(os.Getwd()))")
	g.P("}")
	g.P("")

	g.P("func ParseFloat(sizeStr string) (size float64) {")
	g.P(" return mylog.Check2(strconv.ParseFloat(sizeStr, 64))")
	g.P("}")
	g.P("")

	g.P("func Float64ToString(f float64, prec int) string {")
	g.P(" return strconv.FormatFloat(f, 'f', prec, 64)")
	g.P("}")
	g.P("")

	g.P("func Float64Cut(value float64, bits int) (float64, error) {")
	g.P(" return strconv.ParseFloat(fmt.Sprintf(\"%.\"+strconv.Itoa(bits)+\"f\", value), 64)")
	g.P("}")
	g.P("")

	g.P("func ParseInt(s string) int64 {")
	g.P(" return mylog.Check2(strconv.ParseInt(s, 10, 64))")
	g.P("}")
	g.P("")

	g.P("func ParseUint(s string) uint64 {")
	g.P(" return mylog.Check2(strconv.ParseUint(s, 10, 64))")
	g.P("}")
	g.P("")

	g.P("func Atoi(s string) int {")
	g.P(" return mylog.Check2(strconv.Atoi(s))")
	g.P("}")
	g.P("")

	g.P("func IsTermux() bool {")
	g.P(" r0, e := os.Stat(\"/data/data/com.termux/files/usr\")")
	g.P(" if e == nil {")
	g.P("  return r0.IsDir()")
	g.P(" }")
	g.P(" return false")
	g.P("}")
	g.P("func IsAix() bool       { return runtime.GOOS == \"aix\" }")
	g.P("func IsAndroid() bool   { return runtime.GOOS == \"android\" }")
	g.P("func IsDarwin() bool    { return runtime.GOOS == \"darwin\" }")
	g.P("func IsDragonfly() bool { return runtime.GOOS == \"dragonfly\" }")
	g.P("func IsFreebsd() bool   { return runtime.GOOS == \"freebsd\" }")
	g.P("func IsHurd() bool      { return runtime.GOOS == \"hurd\" }")
	g.P("func IsIllumos() bool   { return runtime.GOOS == \"illumos\" }")
	g.P("func IsIos() bool       { return runtime.GOOS == \"ios\" }")
	g.P("func IsJs() bool        { return runtime.GOOS == \"js\" }")
	g.P("func IsLinux() bool     { return runtime.GOOS == \"linux\" }")
	g.P("func IsNacl() bool      { return runtime.GOOS == \"nacl\" }")
	g.P("func IsNetbsd() bool    { return runtime.GOOS == \"netbsd\" }")
	g.P("func IsOpenbsd() bool   { return runtime.GOOS == \"openbsd\" }")
	g.P("func IsPlan9() bool     { return runtime.GOOS == \"plan9\" }")
	g.P("func IsSolaris() bool   { return runtime.GOOS == \"solaris\" }")
	g.P("func IsWasip1() bool    { return runtime.GOOS == \"wasip1\" }")
	g.P("func IsWindows() bool   { return runtime.GOOS == \"windows\" }")
	g.P("func IsZos() bool       { return runtime.GOOS == \"zos\" }")
	g.P("")

	g.P("var knownOS = map[string]bool{")
	g.P(" \"aix\":       true,")
	g.P(" \"android\":   true,")
	g.P(" \"darwin\":    true,")
	g.P(" \"dragonfly\": true,")
	g.P(" \"freebsd\":   true,")
	g.P(" \"hurd\":      true,")
	g.P(" \"illumos\":   true,")
	g.P(" \"ios\":       true,")
	g.P(" \"js\":        true,")
	g.P(" \"linux\":     true,")
	g.P(" \"nacl\":      true,")
	g.P(" \"netbsd\":    true,")
	g.P(" \"openbsd\":   true,")
	g.P(" \"plan9\":     true,")
	g.P(" \"solaris\":   true,")
	g.P(" \"wasip1\":    true,")
	g.P(" \"windows\":   true,")
	g.P(" \"zos\":       true,")
	g.P("}")
	g.P("")

	g.P("var unixOS = map[string]bool{")
	g.P(" \"aix\":       true,")
	g.P(" \"android\":   true,")
	g.P(" \"darwin\":    true,")
	g.P(" \"dragonfly\": true,")
	g.P(" \"freebsd\":   true,")
	g.P(" \"hurd\":      true,")
	g.P(" \"illumos\":   true,")
	g.P(" \"ios\":       true,")
	g.P(" \"linux\":     true,")
	g.P(" \"netbsd\":    true,")
	g.P(" \"openbsd\":   true,")
	g.P(" \"solaris\":   true,")
	g.P("}")
	g.P("")

	g.P("var knownArch = map[string]bool{")
	g.P(" \"386\":         true,")
	g.P(" \"amd64\":       true,")
	g.P(" \"amd64p32\":    true,")
	g.P(" \"arm\":         true,")
	g.P(" \"armbe\":       true,")
	g.P(" \"arm64\":       true,")
	g.P(" \"arm64be\":     true,")
	g.P(" \"loong64\":     true,")
	g.P(" \"mips\":        true,")
	g.P(" \"mipsle\":      true,")
	g.P(" \"mips64\":      true,")
	g.P(" \"mips64le\":    true,")
	g.P(" \"mips64p32\":   true,")
	g.P(" \"mips64p32le\": true,")
	g.P(" \"ppc\":         true,")
	g.P(" \"ppc64\":       true,")
	g.P(" \"ppc64le\":     true,")
	g.P(" \"riscv\":       true,")
	g.P(" \"riscv64\":     true,")
	g.P(" \"s390\":        true,")
	g.P(" \"s390x\":       true,")
	g.P(" \"sparc\":       true,")
	g.P(" \"sparc64\":     true,")
	g.P(" \"wasm\":        true,")
	g.P("}")
	g.P("")

	g.P("const TimeLayout = \"2006-01-02 15:04:05\"")
	g.P("")

	g.P("func FormatTime(t time.Time) string { return t.Format(TimeLayout) }")
	g.P("func UnFormatTime(s string) time.Time {")
	g.P(" parse := mylog.Check2(time.Parse(TimeLayout, s))")
	g.P(" return parse")
	g.P("}")
	g.P("")

	g.P("func FormatDuration(d time.Duration) string { return d.String() }")
	g.P("func UnFormatDuration(s string) time.Duration {")
	g.P(" duration := mylog.Check2(time.ParseDuration(s))")
	g.P(" return duration")
	g.P("}")
	g.P("func GetTimeNowString() string { return time.Now().Format(\"2006-01-02 15:04:05 \") }")
	g.P("")

	g.P("func GetTimeStamp13Bits() int64 { return time.Now().UnixNano() / 1000000 }")
	g.P("")

	g.P("func GetTimeStamp() string { return strconv.FormatInt(time.Now().UnixNano()/1000000, 10) }")
	g.P("")

	g.P("func GetDiffDays(dstTime string) string {")
	g.P(" t := mylog.Check2(time.Parse(\"2006-01-02\", dstTime))")
	g.P(" now := t.Sub(time.Now())")
	g.P(" days := int(now.Hours() / 24)")
	g.P(" years := days / 365")
	g.P(" months := (days % 365) / 30")
	g.P(" remainingDays := (days % 365) % 30")
	g.P(" hours := int(now.Hours()) % 24")
	g.P(" minutes := int(now.Minutes()) % 60")
	g.P(" seconds := int(now.Seconds()) % 60")
	g.P("")

	g.P(" s := NewBuffer(\"\")")
	g.P(" s.WriteStringLn(fmt.Sprintf(\"相差天数 %d 天\", days))")
	g.P(" s.WriteStringLn(fmt.Sprintf(\"相差年数 %d 年\", years))")
	g.P(" s.WriteStringLn(fmt.Sprintf(\"相差月数 %d 月\", months))")
	g.P(" s.WriteStringLn(fmt.Sprintf(\"相差时数 %d 时\", hours))")
	g.P(" s.WriteStringLn(fmt.Sprintf(\"相差分数 %d 分\", minutes))")
	g.P(" s.WriteStringLn(fmt.Sprintf(\"相差秒数 %d 秒\", seconds))")
	g.P(" s.WriteStringLn(fmt.Sprintf(\"相差时间 %d 年 %d 月 %d 天 %d 时 %d 分 %d 秒\",")
	g.P("  years, months, remainingDays, hours, minutes, seconds))")
	g.P(" return s.String()")
	g.P("}")
	g.P("")

	g.P("func GetUserConfigDirs() (UserConfigDirs map[string]string) {")
	g.P(" UserConfigDirs = make(map[string]string)")
	g.P(" if runtime.GOOS == \"windows\" {")
	g.P("  dir := mylog.Check2(os.UserConfigDir())")
	g.P("  u := mylog.Check2(user.Current())")
	g.P("  UserConfigDirs[u.Username] = dir")
	g.P(" } else if IsTermux() {")
	g.P("  dir := mylog.Check2(os.UserConfigDir())")
	g.P("  u := mylog.Check2(user.Current())")
	g.P("  UserConfigDirs[u.Username] = dir")
	g.P(" } else {")
	g.P("  file := mylog.Check2(os.Open(\"/etc/passwd\"))")
	g.P("  defer func() { mylog.Check(file.Close()) }()")
	g.P("")

	g.P("  scanner := bufio.NewScanner(file)")
	g.P("  for scanner.Scan() {")
	g.P("   line := scanner.Text()")
	g.P("   if strings.HasPrefix(line, \"#\") {")
	g.P("    continue")
	g.P("   }")
	g.P("   parts := strings.Split(line, \":\")")
	g.P("   if len(parts) > 0 {")
	g.P("    username := parts[0]")
	g.P("    u, e := user.Lookup(username)")
	g.P("    mylog.CheckIgnore(e)")
	g.P("    if e != nil {")
	g.P("     continue")
	g.P("    }")
	g.P("    dir := u.HomeDir + \"/.config\"")
	g.P("    if strings.Contains(dir, \"root\") || strings.Contains(dir, \"home\") {")
	g.P("     UserConfigDirs[username] = dir")
	g.P("    }")
	g.P("   }")
	g.P("  }")
	g.P(" }")
	g.P(" return UserConfigDirs")
	g.P("}")
	g.P("")

	g.P("var RegexpCenter = `(.+?)`")
	g.P("")

	g.P("func RegexpWebBodyBlocks(tagName string) string {")
	g.P(" return `<` + tagName + `[^>]*?>[\\w\\W]*?<\\/` + tagName + `>`")
	g.P("}")
	g.P("")

	g.P("func IntegerToIP(ip int64) string {")
	g.P(" return fmt.Sprintf(\"%d.%d.%d.%d\", byte(ip>>24), byte(ip>>16), byte(ip>>8), byte(ip))")
	g.P("}")
	g.P("")

	g.P("var (")
	g.P(" RegexpIp     = regexp.MustCompile(`((25[0-5]|2[0-4]\\d|((1\\d{2})|([1-9]?\\d)))\\.){3}(25[0-5]|2[0-4]\\d|((1\\d{2})|([1-9]?\\d)))`)")
	g.P(" RegexpIpPort = regexp.MustCompile(`((25[0-5]|2[0-4]\\d|((1\\d{2})|([1-9]?\\d)))\\.){3}(25[0-5]|2[0-4]\\d|((1\\d{2})|([1-9]?\\d))):([0-9]+)`)")
	g.P(")")

	callBack(g.Buffer)
	stream.WriteGoFile(path, g.Buffer)
}
