package stream

import (
	_ "embed"
	"fmt"
	"go/format"
	"path/filepath"
	"reflect"
	"strconv"
	"strings"

	"github.com/ddkwork/golibrary/mylog"
	"github.com/ddkwork/golibrary/safemap"
)

type GeneratedFile struct {
	*Buffer
	packageName  string
	filePath     string
	enumBase     int
	type_        reflect.Type
	values       []uint32 // stream.Signed
	callBack     func(is bool, v string) string
	keepOrigName bool
	imports      map[string]bool
}

func (g *GeneratedFile) SetKeepOrigName(keepOrigName bool) *GeneratedFile {
	g.keepOrigName = keepOrigName
	return g
}

func (g *GeneratedFile) SetCallBack(callBack func(is bool, v string) string) {
	g.callBack = callBack
}

func (g *GeneratedFile) SetValues(values []uint32) *GeneratedFile {
	g.values = values
	return g
}

func (g *GeneratedFile) SetFilePath(filePath string) *GeneratedFile {
	g.filePath = filePath
	return g
}

func (g *GeneratedFile) AddImport(pkg string) { g.imports[pkg] = true }
func (g *GeneratedFile) InsertPackageWithImports(packageName string) *GeneratedFile {
	g.packageName = packageName
	s := g.String()
	g.Reset()
	g.P("package ", packageName)
	g.P("import (")
	for s := range g.imports {
		g.P(strconv.Quote(s))
	}
	g.P(")")
	g.P(s)
	return g
}

func NewGeneratedFile() (g *GeneratedFile) {
	return &GeneratedFile{
		Buffer:       NewBuffer(""),
		packageName:  "",
		filePath:     "",
		enumBase:     0,
		type_:        nil,
		values:       nil,
		callBack:     nil,
		keepOrigName: false,
		imports:      make(map[string]bool),
	}
}

func (g *GeneratedFile) Format() string {
	return string(mylog.Check2(format.Source(g.Bytes())))
}

func (g *GeneratedFile) PC(is64Bit bool, v string) {
	g.P(g.callBack(is64Bit, v))
}

func (g *GeneratedFile) PKeepSpace(v ...any) { // for gen github action yml file
	g.p(true, v...)
}

func (g *GeneratedFile) P(v ...any) {
	g.p(false, v...)
}

func (g *GeneratedFile) p(keepSpace bool, v ...any) {
	for _, x := range v {
		s, ok := x.(string)
		if ok {
			if strings.Contains(s, "\n") {
				if !keepSpace {
					s = strings.TrimSpace(s)
				}
				s = strings.TrimPrefix(s, "\n")
				x = s
			}
		}
		mylog.Check2(fmt.Fprint(g, x))
	}
	mylog.Check2(fmt.Fprintln(g))
}

func (g *GeneratedFile) SetEnumBase(base int) *GeneratedFile {
	g.enumBase = base
	return g
}

func (g *GeneratedFile) SetEnumType(t reflect.Type) *GeneratedFile {
	g.type_ = t
	return g
}

func (g *GeneratedFile) EnumTypes(name string, TypeTooltipMap *safemap.M[string, string]) {
	mylog.Call(func() {
		var (
			names    []string
			tooltips []string
		)
		for key, value := range TypeTooltipMap.Range() {
			names = append(names, strings.TrimSpace(key))
			tooltips = append(tooltips, strings.TrimSpace(value))
		}
		for i, Name := range names {
			if !g.keepOrigName {
				names[i] = ToCamelUpper(Name)
			}
		}
		TypeNameUpper := ToCamelUpper(name)
		if g.packageName == "" {
			g.packageName = GetPackageName()
		}
		g.P("package ", g.packageName)
		g.P("")

		g.P(`
import (
	"github.com/ddkwork/golibrary/stream"
	"strings"
)
`)
		g.P("")

		g.P("// Code generated by EnumTypesGen - DO NOT EDIT.")
		g.P("")

		fnInvalidType := func() {
			g.P(" panic(", strconv.Quote("InvalidType"), ")")
		}
		const Type = "Type"
		method := TypeNameUpper + Type

		if g.type_ == nil {
			g.type_ = reflect.TypeFor[byte]()
		}
		g.P("type ", method, " ", g.type_.String())
		g.P("")
		g.P("const (")
		for i, n := range names {
			if g.values != nil {
				if len(g.values) != len(names) {
					panic("values length not equal to names length")
				}
				g.P(" ", n, Type, " ", method, " = ", g.values[i])
				continue
			}
			if i == 0 {
				base := "iota"
				if g.enumBase != 0 {
					base += "+" + strconv.Itoa(g.enumBase)
				}
				g.P(" ", n, Type, " ", method, " = ", base)
				continue
			}
			g.P(" "+n, Type)
		}

		g.P(")")
		g.P("")

		mixTypeName := names[0] + Type
		maxTypeName := names[len(names)-1] + Type
		g.P("func (t ", method, ") Valid() bool {")
		g.P(" return t >= ", mixTypeName, " && t <= ", maxTypeName)
		g.P("}")
		g.P("")

		g.P("func ", method, "By ", "[T stream.Integer](v T)", method, "  {")
		g.P("  return ", method, "(v)")
		g.P("}")
		g.P("")

		g.P("func (t ", method, ") AssertBy(name string) ", method, " {")
		g.P("name=strings.TrimSuffix(name,\"Type\")")
		g.P(" for _, n := range t.EnumTypes() {")
		g.P("  if strings.EqualFold(name,n.String()) {")
		g.P("   return n")
		g.P("  }")
		g.P(" }")
		fnInvalidType()
		g.P("}")
		g.P("")

		g.P("func (t ", method, ") String() string {")
		g.P(" switch t {")
		for _, n := range names {
			g.P(" case ", n, Type, ":")
			g.P("  return ", strconv.Quote(n))
		}
		g.P(" default:")
		fnInvalidType()
		g.P(" }")
		g.P("}")
		g.P("")

		if len(tooltips) > 0 {
			g.P("func (t ", method, ") Tooltip() string {")
			g.P(" switch t {")
			for i, n := range names {
				g.P(" case ", n, Type, ":")
				g.P("  return ", strconv.Quote(tooltips[i]))
			}
			g.P(" default:")
			fnInvalidType()
			g.P(" }")
			g.P("}")
			g.P("")
		}

		g.P("func (t ", method, ") Names() []string {")
		g.P(" return []string{")
		for _, n := range names {
			g.P("  ", strconv.Quote(n), ",")
		}
		g.P(" }")
		g.P("}")
		g.P("")

		g.P("func (t ", method, ") EnumTypes() []", method, " {")
		g.P(" return []", method, "{")
		for _, n := range names {
			g.P("  ", n, Type, ",")
		}
		g.P(" }")
		g.P("}")
		g.P("")

		g.P("func (t ", method, ") SvgFileName() string {")
		g.P(" return t.String() + \".svg\"")
		g.P("}")
		g.P("")
		WriteGoFile(filepath.Join(g.filePath, name+"_types_gen.go"), g.Buffer)
		g.Reset()
	})
}

func (g *GeneratedFile) ReadTemplates(path, pkg string) {
	pkg = strings.TrimSuffix(pkg, "_test")
	mylog.Call(func() {
		s := NewBuffer("package " + pkg + "_test")
		s.NewLine()
		s.WriteStringLn(`
   import (
			"github.com/ddkwork/golibrary/stream"
		)`)
		s.NewLine()

		s.WriteStringLn("func generateIR(path string,callBack func(b*stream.Buffer)) {")
		s.WriteStringLn("g := stream.NewGeneratedFile()")
		for line := range ReadFileToLines(path) {
			needNewLine := false
			if line == "" {
				needNewLine = true
			}
			if strings.HasPrefix(line, "package") {
				packageName := "package " + GetPackageName()
				line = "g.P(" + strconv.Quote(packageName) + ")"
			} else {
				line = strings.ReplaceAll(line, "\t", " ")
				line = "g.P(" + strconv.Quote(line) + ")"

			}
			s.WriteStringLn(line)
			if needNewLine {
				s.NewLine()
			}
		}
		s.NewLine()
		s.WriteStringLn("callBack(g.Buffer)")
		// s.WriteStringLn("stream.WriteGoFile(" + strconv.Quote(BaseName(path)+"_gen.go") + ", g.Buffer())")
		s.WriteStringLn("stream.WriteGoFile(path, g.Buffer)")
		s.WriteStringLn("}")
		println(s.String())
	})
}
